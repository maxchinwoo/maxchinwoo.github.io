<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>2인 실시간 그림판</title>
<style>
  :root{--bg:#0b0f14;--panel:#121821;--card:#101725;--pri:#4ea1ff;--txt:#e8f1ff;--sub:#a7bed3;}
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--txt);font-family:system-ui,Arial}
  header{padding:10px 14px;background:var(--panel);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  header > *{margin:0}
  #roomInfo{font-size:14px;color:var(--sub)}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-left:auto}
  .toolbar input[type="color"], .toolbar input[type="range"], .toolbar button{cursor:pointer}
  .wrap{padding:10px}
  canvas{background:#0d1220;border:2px solid var(--pri);border-radius:10px;display:block;margin:0 auto;touch-action:none;max-width:100%;height:auto}
  .hint{margin-top:8px;text-align:center;color:var(--sub);font-size:13px}
  .badge{background:#1a2233;padding:4px 8px;border-radius:999px}
</style>
</head>
<body>
<header>
  <h3 style="margin-right:8px">2인 실시간 그림판</h3>
  <span id="roomInfo" class="badge">방: (연결 중...)</span>
  <span id="peerInfo" class="badge">접속 인원: -</span>
  <div class="toolbar">
    선색 <input id="color" type="color" value="#ffffff"/>
    굵기 <input id="size" type="range" min="1" max="40" value="6"/>
    <button id="clearBtn">지우기</button>
  </div>
</header>
<div class="wrap">
  <canvas id="board" width="1200" height="700"></canvas>
  <div class="hint">같은 링크의 <b>?room=같은이름</b>으로 접속하면 같은 방에 들어옵니다. 최대 2명.</div>
</div>

<!-- Socket.IO client (CDN) -->
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
  // 1) 서버 URL
  const WS_URL = "http://34.169.81.154:8080"; // ← VM 외부 IP 확인 후 맞게 수정하세요

  // 2) 방 이름
  const params = new URLSearchParams(location.search);
  const room = params.get("room") || "room1";
  document.getElementById('roomInfo').textContent = `방: ${room}`;

  // 3) Canvas 준비
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  function fitCanvas() {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssWidth = Math.min(window.innerWidth - 20, 1200);
    const cssHeight = Math.min(window.innerHeight - 90, 700);
    canvas.style.width = cssWidth + "px";
    canvas.style.height = cssHeight + "px";
    canvas.width = Math.floor(cssWidth * dpr);
    canvas.height = Math.floor(cssHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // 4) 그리기 상태
  const colorEl = document.getElementById('color');
  const sizeEl  = document.getElementById('size');
  const clearBtn = document.getElementById('clearBtn');
  let drawing = false;
  let last = null;

  function beginStroke(x,y) {
    drawing = true;
    last = {x,y};
    ctx.beginPath();
    ctx.moveTo(x,y);
  }
  function moveStroke(x,y,col,sz) {
    if(!drawing) return;
    ctx.strokeStyle = col; ctx.lineWidth = sz; ctx.lineCap = 'round'; ctx.lineJoin='round';
    ctx.lineTo(x,y);
    ctx.stroke();
    last = {x,y};
  }
  function endStroke() { drawing = false; last = null; }

  // 5) 입력 핸들러
  function posFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    if(e.touches && e.touches[0]) {
      return { x: e.touches[0].clientX - rect.left, y: e.touches[0].clientY - rect.top };
    } else {
      return { x: e.clientX - rect.left, y: e.clientY - rect.top };
    }
  }
  canvas.addEventListener('mousedown', e=>{
    const p = posFromEvent(e); beginStroke(p.x,p.y);
    socket.emit('draw', {room, t:'b', x:p.x, y:p.y});
  });
  canvas.addEventListener('mousemove', e=>{
    if(!drawing) return;
    const p = posFromEvent(e);
    moveStroke(p.x,p.y, colorEl.value, Number(sizeEl.value));
    socket.emit('draw', {room, t:'m', x:p.x, y:p.y, c:colorEl.value, s:Number(sizeEl.value)});
  });
  window.addEventListener('mouseup', e=>{
    if(drawing) {
      endStroke();
      socket.emit('draw', {room, t:'e'});
    }
  });

  canvas.addEventListener('touchstart', e=>{
    e.preventDefault();
    const p = posFromEvent(e); beginStroke(p.x,p.y);
    socket.emit('draw', {room, t:'b', x:p.x, y:p.y});
  }, {passive:false});
  canvas.addEventListener('touchmove', e=>{
    e.preventDefault();
    const p = posFromEvent(e);
    moveStroke(p.x,p.y, colorEl.value, Number(sizeEl.value));
    socket.emit('draw', {room, t:'m', x:p.x, y:p.y, c:colorEl.value, s:Number(sizeEl.value)});
  }, {passive:false});
  canvas.addEventListener('touchend', e=>{
    e.preventDefault();
    if(drawing){ endStroke(); socket.emit('draw', {room, t:'e'}); }
  });

  clearBtn.addEventListener('click', ()=>{
    ctx.clearRect(0,0,canvas.width,canvas.height);
    socket.emit('clear', {room});
  });

  // 6) 소켓 연결
  const socket = io(WS_URL, {transports:['websocket']});
  socket.on('connect', ()=>{
    console.log("서버에 연결됨");
    socket.emit('join', {room});
  });
  socket.on('room_full', ()=>{
    alert('이 방은 이미 2명이 사용 중입니다. 다른 방 이름으로 접속해주세요. (예: ?room=room2)');
  });
  socket.on('peer_count', n=>{
    document.getElementById('peerInfo').textContent = `접속 인원: ${n}`;
  });
  socket.on('draw', msg=>{
    if(msg.t==='b'){ beginStroke(msg.x, msg.y); }
    else if(msg.t==='m'){ moveStroke(msg.x, msg.y, msg.c, msg.s); }
    else if(msg.t==='e'){ endStroke(); }
  });
  socket.on('clear', ()=>{
    ctx.clearRect(0,0,canvas.width,canvas.height);
  });
</script>
</body>
</html>
