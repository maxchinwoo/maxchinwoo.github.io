<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Pacman 15x15 Grid (snapped)</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    color: #fff;
    font-family: system-ui, Arial, sans-serif;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
    user-select:none;
    touch-action: none;
  }
  .wrap {
    position: relative;
    height: 100vh;
    display: grid;
    grid-template-rows: auto 1fr;
    overflow: hidden;
    padding-top: env(safe-area-inset-top);
  }
  .topbar {
    display: flex;
    gap: 10px;
    align-items: center;
    justify-content: center;
    padding: 6px 10px;
  }
  #resetBtn {
    padding: 8px 14px;
    font-size: 1rem;
    border: none;
    border-radius: 10px;
    background: #1e90ff;
    color: #fff;
    cursor: pointer;
  }
  #resetBtn:active { filter: brightness(0.9); }

  .stage {
    position: relative;
    display: grid;
    place-items: center;
    transform: translateY(-2vh); /* í™”ë©´ ì‚´ì§ ìœ„ë¡œ */
  }

  /* ìº”ë²„ìŠ¤ëŠ” ì •ì‚¬ê°í˜•, 15x15ì— ë§ì¶¤ */
  canvas {
    width: min(92vmin, 92vw, 92vh);
    height: min(92vmin, 92vw, 92vh);
    background: #000;
    border: 2px solid #1e90ff;  /* 15x15 ì™¸ê³½ í…Œë‘ë¦¬ */
    border-radius: 12px;
    box-shadow: 0 0 20px rgba(30,144,255,0.3);
    image-rendering: pixelated;
  }

  .hud {
    position: absolute;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    font-size: 18px;
    letter-spacing: .5px;
    text-align: center;
    white-space: nowrap;
    pointer-events: none;
  }
  .overlay {
    position: absolute;
    inset: 0;
    display: none;
    place-items: center;
    background: rgba(0,0,0,0.55);
    text-align: center;
    padding: 20px;
  }
  .overlay.show { display: grid; }
  .overlay h2 { margin: 0 0 8px 0; }
  .overlay p { margin: 4px 0; }

  /* === ë™ì  ì¡°ì´ìŠ¤í‹± === */
  .joystick {
    position: absolute;
    left: 0; top: 0;
    width: 0; height: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity .08s ease;
  }
  .joy-base {
    position: absolute;
    width: 160px; height: 160px;
    margin-left: -80px; margin-top: -80px;
    border-radius: 50%;
    background: radial-gradient(ellipse at center, #1b1b1b 0%, #121212 70%);
    border: 2px solid #3a3a3a;
    box-shadow: 0 8px 24px rgba(0,0,0,0.45), inset 0 0 14px rgba(255,255,255,0.06);
  }
  .joy-knob {
    position: absolute;
    width: 88px; height: 88px;
    margin-left: -44px; margin-top: -44px;
    border-radius: 50%;
    background: radial-gradient(ellipse at center, #2a2a2a 0%, #1d1d1d 70%);
    border: 2px solid #5a5a5a;
    box-shadow: 0 6px 16px rgba(0,0,0,0.6), inset 0 0 10px rgba(30,144,255,0.3);
  }
</style>
</head>
<body>
<div class="wrap" id="wrap">
  <div class="topbar">
    <button id="resetBtn">ğŸ”„ ë¦¬ì…‹</button>
    <button id="homeBtn">ğŸ  í™ˆ</button>
  </div>

  <div class="stage" id="stage">
    <!-- 15x15 ê·¸ë¦¬ë“œë¥¼ ì •í™•íˆ ì±„ìš°ëŠ” 420x420 -->
    <canvas id="game" width="420" height="420"></canvas>
    <div class="hud" id="hud">SCORE: 0<br/>TIME: 0.00s</div>

    <div class="overlay" id="overlay">
      <div>
        <h2 id="endTitle">ğŸ‰ í´ë¦¬ì–´!</h2>
        <p id="finalTime">ê¸°ë¡: -</p>
        <p id="finalScore">ì ìˆ˜: -</p>
        <button id="overlayReset" style="padding:10px 16px;border:none;border-radius:10px;background:#1e90ff;color:#fff;cursor:pointer;">ë‹¤ì‹œ ì‹œì‘</button>
      </div>
    </div>

    <div class="joystick" id="joystick">
      <div class="joy-base" id="joyBase"></div>
      <div class="joy-knob" id="joyKnob"></div>
    </div>
  </div>
</div>

<script>
/* ====== ê¸°ë³¸ ì„¤ì • (15x15 ì „ìš©) ====== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const hud = document.getElementById('hud');
const overlay = document.getElementById('overlay');
const endTitle = document.getElementById('endTitle');
const finalTime = document.getElementById('finalTime');
const finalScore = document.getElementById('finalScore');
const overlayReset = document.getElementById('overlayReset');
const resetBtn = document.getElementById('resetBtn');

const ROWS = 15, COLS = 15;
const TILE = canvas.width / COLS;   // 420/15 = 28
const HALF = TILE / 2;

const BASE_SPEED = 4;
const SPEED_MULT = 0.25;
const SPEED = BASE_SPEED * SPEED_MULT;       // px/frame (ê²©ìì„  ì´ë™)
const GHOST_SPEED = SPEED * 0.9;

const DOT_RADIUS = 3;
const PELLET_SCORE = 10;

const COLLIDE_RADIUS = TILE * 0.6;
const FREEZE_MS = 3000;

/* ì¥ì• ë¬¼ ê°œìˆ˜(ë‚´ë¶€ 13x13ì—ì„œ ì •í™•íˆ ì´ë§Œí¼ ë°°ì¹˜, ì œì•½ ì¶©ì¡± ì¹¸ë§Œ) */
const WALL_COUNT = 28;  // í•„ìš”í•œ ë§Œí¼ ì¡°ì • ê°€ëŠ¥

/* ====== ìƒíƒœ ====== */
let maze = [];              // 1=ë²½, 0=ê¸¸ (15x15)
let pellets = new Set();    // "r,c"
let score = 0;
let startTime = null;
let elapsed = 0;
let isRunning = false;
let gameOver = false;

const pacman = {
  r: 1, c: 1,               // ì…€ ì¢Œí‘œ
  dir: {x:0, y:0},          // (-1/0/1)
  want:{x:0, y:0},
  frozenUntil: 0,
  hurtTintUntil: 0,
  radius: TILE*0.45,
  _acc: 0
};

function cellCenterX(c){ return c*TILE + HALF; }
function cellCenterY(r){ return r*TILE + HALF; }

/* ğŸ‘¾ ìœ ë ¹ */
function makeGhost(r,c,color){
  return { r, c, dir: [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}][Math.floor(Math.random()*4)], color, _acc:0 };
}
let ghosts = [];
const MAX_GHOSTS = 6;

/* ====== ìœ í‹¸ & ì œì•½ ê²€ì‚¬ ====== */
function inBounds(r,c){ return r>=0 && r<ROWS && c>=0 && c<COLS; }
function isWall(r,c){ return !inBounds(r,c) || maze[r][c]===1; }
function nowMs(){ return performance.now(); }
const DIRS = [[1,0],[-1,0],[0,1],[0,-1]];

/* (wr,wc)ì— ë²½ì„ ì„¸ìš°ë©´ ì¸ì ‘ ë¹ˆì¹¸ì´ 4ë©´ ë§‰íŒ 'ê³ ë¦½ì¹¸'ì´ ìƒê¸°ëŠ”ì§€ */
function wouldMakeDeadCell(wr, wc){
  for (const [dr,dc] of DIRS){
    const r = wr + dr, c = wc + dc;
    if (!inBounds(r,c) || maze[r][c]===1) continue;
    let walls = 0;
    for (const [d2r,d2c] of DIRS){
      const nr = r + d2r, nc = c + d2c;
      if ((nr===wr && nc===wc) || isWall(nr,nc)) walls++;
    }
    if (walls === 4) return true;
  }
  return false;
}

/* ì‹œì‘ì (1,1)ì—ì„œ ëª¨ë“  ë¹ˆì¹¸ì´ ì—°ê²°ë¼ ìˆëŠ”ì§€ */
function isConnected(){
  let totalEmpty = 0;
  for (let r=0;r<ROWS;r++) for (let c=0;c<COLS;c++) if (maze[r][c]===0) totalEmpty++;

  const sr = 1, sc = 1;
  if (maze[sr][sc]===1) return false;

  const q = [[sr,sc]];
  const seen = Array.from({length:ROWS},()=>Array(COLS).fill(false));
  seen[sr][sc]=true;
  let visited = 1;

  while (q.length){
    const [r,c] = q.shift();
    for (const [dr,dc] of DIRS){
      const nr=r+dr, nc=c+dc;
      if (!inBounds(nr,nc) || seen[nr][nc]) continue;
      if (maze[nr][nc]===0){
        seen[nr][nc]=true;
        visited++;
        q.push([nr,nc]);
      }
    }
  }
  return visited === totalEmpty;
}

/* ë‚´ë¶€ 13Ã—13ì— ì œì•½ì„ ë§Œì¡±í•˜ëŠ” ë²½ì„ WALL_COUNTê°œ ë°°ì¹˜ */
function placeRandomWallsWithConstraints(){
  const cand = [];
  for (let r=1;r<ROWS-1;r++){
    for (let c=1;c<COLS-1;c++){
      if (r>=1 && r<=3 && c>=1 && c<=3) continue; // ì‹œì‘êµ¬ì—­ ì œì™¸
      cand.push([r,c]);
    }
  }
  cand.sort(()=>Math.random()-0.5); // ì…”í”Œ

  let placed = 0;
  for (let i=0; i<cand.length && placed<WALL_COUNT; i++){
    const [r,c] = cand[i];
    if (maze[r][c]===1) continue;
    if (wouldMakeDeadCell(r,c)) continue;

    // ì„ì‹œë¡œ ì„¸ì›Œì„œ ì—°ê²°ì„± í™•ì¸
    maze[r][c] = 1;
    if (!isConnected()){
      maze[r][c] = 0; // ë˜ëŒë¦¼
      continue;
    }
    placed++;
  }
}

/* ====== ë§µ ìƒì„±: í…Œë‘ë¦¬=ë²½, ë‚´ë¶€=ê¸¸ â†’ ì œì•½ ì¶©ì¡± ë²½ ë°°ì¹˜ ====== */
function generateMaze(){
  maze = Array.from({length:ROWS},()=>Array(COLS).fill(0));

  // í…Œë‘ë¦¬ ë²½
  for (let r=0;r<ROWS;r++){ maze[r][0]=1; maze[r][COLS-1]=1; }
  for (let c=0;c<COLS;c++){ maze[0][c]=1; maze[ROWS-1][c]=1; }

  // ì‹œì‘ êµ¬ì—­(1..3,1..3) ë¹„ìš°ê¸°
  for (let r=1;r<=3;r++) for (let c=1;c<=3;c++) maze[r][c]=0;

  // ë‚´ë¶€ 13Ã—13ì— ë²½ ë°°ì¹˜
  placeRandomWallsWithConstraints();
}

/* í ë¦¿: ì „ì²´ 15x15 ë‚´ë¶€ ê¸¸ ìœ„ */
function scatterPellets(){
  pellets = new Set();
  for (let r=1;r<ROWS-1;r++){
    for (let c=1;c<COLS-1;c++){
      if (maze[r][c]===0) pellets.add(`${r},${c}`);
    }
  }
}

function emptyCells(excludeStart=true){
  const arr=[];
  for (let r=1;r<ROWS-1;r++){
    for (let c=1;c<COLS-1;c++){
      if (maze[r][c]===0){
        if (excludeStart && (r<=3 && c<=3)) continue;
        arr.push({r,c});
      }
    }
  }
  return arr;
}
function addGhostRandom(color){
  const cells = emptyCells(true);
  if (!cells.length) return;
  const {r,c} = cells[Math.floor(Math.random()*cells.length)];
  ghosts.push(makeGhost(r,c,color));
}
function placeActors(){
  pacman.r=1; pacman.c=1; pacman.dir={x:0,y:0}; pacman.want={x:0,y:0};
  pacman.frozenUntil=0; pacman.hurtTintUntil=0; pacman._acc=0;

  ghosts = [];
  addGhostRandom('#ff4d4d');
  addGhostRandom('#7ad1ff');
}

/* ====== ì´ë™ (ê²©ì ìŠ¤ëƒ…) ====== */
function canMove(r,c){ return inBounds(r,c) && maze[r][c]===0; }

function tryTurnGrid(actor){
  const w = actor===pacman ? pacman.want : actor.want;
  if (!w || (w.x===0 && w.y===0)) return;
  const nr = actor.r + w.y, nc = actor.c + w.x;
  if (canMove(nr, nc)) actor.dir = {x:w.x, y:w.y};
}

function stepAlongGrid(actor, speed){
  const dir = actor.dir;
  if (dir.x===0 && dir.y===0) return;
  const nr = actor.r + dir.y;
  const nc = actor.c + dir.x;

  if (canMove(nr, nc)){
    actor._acc = (actor._acc||0) + speed;
    if (actor._acc >= TILE){
      actor._acc -= TILE;
      actor.r = nr; actor.c = nc;
    }
  } else {
    actor.dir = {x:0,y:0};
    actor._acc = 0;
  }
}

/* íŒ©ë§¨ ì´ë™ */
function movePacman(){
  if (nowMs() < pacman.frozenUntil) return;
  if ((pacman.dir.x===0 && pacman.dir.y===0) || pacman._acc===0) tryTurnGrid(pacman);
  stepAlongGrid(pacman, SPEED);

  const key = `${pacman.r},${pacman.c}`;
  if (pellets.has(key)){ pellets.delete(key); score += PELLET_SCORE; }
}

/* ìœ ë ¹ ì´ë™ (í”Œë ˆì´ì–´ ìª½ ê°€ë” ìš°ì„ ) */
function dirsTowardPlayerFrom(r,c){
  const cand = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
  return cand.sort((a,b)=>{
    const da = Math.abs((c+a.x) - pacman.c) + Math.abs((r+a.y) - pacman.r);
    const db = Math.abs((c+b.x) - pacman.c) + Math.abs((r+b.y) - pacman.r);
    return da - db;
  });
}
function randomDirs(){ return [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].sort(()=>Math.random()-0.5); }
function moveGhost(g){
  if (!g.dir || g._acc===0){
    const pri = (Math.random()<0.12) ? dirsTowardPlayerFrom(g.r,g.c) : randomDirs();
    let set=false;
    for (const d of pri){
      if (canMove(g.r + d.y, g.c + d.x)){ g.dir=d; set=true; break; }
    }
    if (!set) g.dir={x:0,y:0};
  }
  stepAlongGrid(g, GHOST_SPEED);
}

/* ì¶©ëŒ */
function hitGhost(){
  for (const g of ghosts){
    if (g.r===pacman.r && g.c===pacman.c) return true;
  }
  return false;
}
function applyFreezePenalty(){
  pacman.frozenUntil = nowMs() + FREEZE_MS;
  pacman.hurtTintUntil = nowMs() + 500;
}

/* ====== ê·¸ë¦¬ê¸° ====== */
function drawMaze(){
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      if (maze[r][c]===1){
        ctx.fillStyle = '#113b8f';
        ctx.fillRect(c*TILE, r*TILE, TILE, TILE);
      }
    }
  }
  ctx.fillStyle = '#ffd54a';
  pellets.forEach(k=>{
    const [r,c] = k.split(',').map(Number);
    const cx = c*TILE + HALF, cy = r*TILE + HALF;
    ctx.beginPath();
    ctx.arc(cx, cy, DOT_RADIUS, 0, Math.PI*2);
    ctx.fill();
  });
}
function drawPacman(){
  const frozen = nowMs() < pacman.frozenUntil;
  const hurt = nowMs() < pacman.hurtTintUntil;
  const cx = pacman.c*TILE + HALF, cy = pacman.r*TILE + HALF;

  ctx.fillStyle = hurt ? '#ff6b6b' : '#ffeb3b';
  const mouthOpen = frozen ? 0.1 : 0.35;
  const ang = Math.atan2(pacman.dir.y, pacman.dir.x) || 0;
  ctx.beginPath();
  ctx.moveTo(cx, cy);
  ctx.arc(cx, cy, pacman.radius, ang + mouthOpen, ang - mouthOpen, false);
  ctx.closePath();
  ctx.fill();
}
function drawGhost(g){
  const cx = g.c*TILE + HALF, cy = g.r*TILE + HALF, r = TILE*0.45;
  ctx.fillStyle = g.color;
  ctx.beginPath();
  ctx.arc(cx, cy, r, Math.PI, 0);
  ctx.lineTo(cx + r, cy + r);
  const teeth = 4;
  for (let i=teeth; i>=0; i--){
    const px = cx - r + (2*r/teeth)*i;
    const py = cy + r - ((i%2) ? r*0.25 : 0);
    ctx.lineTo(px, py);
  }
  ctx.closePath();
  ctx.fill();
}

/* HUD */
function updateHud(){
  const t = isRunning && startTime ? ((performance.now() - startTime)/1000) : elapsed;
  hud.innerHTML = `SCORE: ${score}<br/>TIME: ${t.toFixed(2)}s`;
}

/* ë£¨í”„ */
function gameStep(){
  if (gameOver){ updateHud(); return; }

  if (isRunning){
    // 10ì´ˆë§ˆë‹¤ ìœ ë ¹ ì¶”ê°€ (ìµœëŒ€ 6)
    const sec = (performance.now() - startTime) / 1000;
    const target = Math.min(MAX_GHOSTS, 2 + Math.floor(sec / 10));
    while (ghosts.length < target){
      const palette = ['#ff4d4d','#7ad1ff','#ff99ff','#ffd166','#66ffa3','#ffb26b'];
      const color = palette[(ghosts.length-1)%palette.length];
      addGhostRandom(color);
    }

    movePacman();
    ghosts.forEach(moveGhost);

    if (hitGhost()) applyFreezePenalty();

    elapsed = (performance.now() - startTime) / 1000;

    if (pellets.size===0){
      gameOver = true;
      endTitle.textContent = 'ğŸ‰ í´ë¦¬ì–´!';
      finalTime.textContent = `ê¸°ë¡: ${elapsed.toFixed(2)}ì´ˆ`;
      finalScore.textContent = `ì ìˆ˜: ${score}`;
      overlay.classList.add('show');
    }
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);
  drawMaze();
  if (!gameOver) drawPacman();
  ghosts.forEach(drawGhost);
  updateHud();

  requestAnimationFrame(gameStep);
}

/* ====== ì…ë ¥: í‚¤ë³´ë“œ ====== */
window.addEventListener('keydown', (e)=>{
  let used=true;
  if (e.key==='ArrowUp')    pacman.want = {x:0,y:-1};
  else if (e.key==='ArrowDown') pacman.want = {x:0,y:1};
  else if (e.key==='ArrowLeft') pacman.want = {x:-1,y:0};
  else if (e.key==='ArrowRight')pacman.want = {x:1,y:0};
  else used=false;

  if (used){
    if (!isRunning){ isRunning = true; if (!startTime) startTime = performance.now(); }
    e.preventDefault();
  }
});

/* ğŸ”´ í‚¤ì—ì„œ ì† ë–¼ë©´ ì¦‰ì‹œ ë©ˆì¶¤ */
window.addEventListener('keyup', (e)=>{
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.key)) {
    pacman.want = {x:0, y:0};
    pacman.dir  = {x:0, y:0};
    pacman._acc = 0;
  }
});

/* ====== ì…ë ¥: ë™ì  ì¡°ì´ìŠ¤í‹± ====== */
const stage = document.getElementById('stage');
const joy = document.getElementById('joystick');
const joyBase = document.getElementById('joyBase');
const joyKnob = document.getElementById('joyKnob');

let joyActive=false;
let joyCenter={x:0,y:0};
const MAX_RADIUS=60;

function showJoystick(x,y){ joy.style.left=x+'px'; joy.style.top=y+'px'; joy.style.opacity=1; }
function hideJoystick(){ joy.style.opacity=0; }

function setKnob(dx,dy){
  const len = Math.hypot(dx,dy);
  const clamped = Math.min(len, MAX_RADIUS);
  const nx = len>0 ? dx*(clamped/len) : 0;
  const ny = len>0 ? dy*(clamped/len) : 0;
  joyKnob.style.left = (joyCenter.x + nx) + 'px';
  joyKnob.style.top  = (joyCenter.y + ny) + 'px';

  if (len<10){ pacman.want={x:0,y:0}; return; }
  pacman.want = (Math.abs(dx)>=Math.abs(dy)) ? {x:Math.sign(dx), y:0} : {x:0, y:Math.sign(dy)};
  if (!isRunning){ isRunning=true; if (!startTime) startTime=performance.now(); }
}

function getPoint(e){ return (e.touches && e.touches[0]) ? {x:e.touches[0].clientX, y:e.touches[0].clientY} : {x:e.clientX, y:e.clientY}; }
function onPointerDown(e){
  e.preventDefault();
  const p=getPoint(e);
  joyActive=true; showJoystick(p.x,p.y);
  joyCenter={x:0,y:0};
  joyBase.style.left='0px'; joyBase.style.top='0px';
  joyKnob.style.left='0px'; joyKnob.style.top='0px';
  if (!isRunning){ isRunning=true; if (!startTime) startTime=performance.now(); }
}
function onPointerMove(e){
  if (!joyActive) return;
  e.preventDefault();
  const rect = joy.getBoundingClientRect();
  const p=getPoint(e);
  setKnob(p.x - rect.left, p.y - rect.top);
}
function onPointerUp(e){
  if (!joyActive) return;
  e.preventDefault();
  joyActive=false; hideJoystick();
  pacman.want={x:0,y:0};
  pacman.dir={x:0,y:0};   // ğŸ”´ ì† ë–¼ë©´ ì¦‰ì‹œ ë©ˆì¶¤
  pacman._acc=0;
}

stage.addEventListener('touchstart', onPointerDown, {passive:false});
stage.addEventListener('touchmove',  onPointerMove,  {passive:false});
stage.addEventListener('touchend',   onPointerUp,    {passive:false});
stage.addEventListener('mousedown',  onPointerDown);
window.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup',   onPointerUp);

/* ====== ë¦¬ì…‹ & ì‹œì‘ ====== */
function resetGame(){
  score=0; startTime=null; elapsed=0; isRunning=false; gameOver=false;
  overlay.classList.remove('show');
  endTitle.textContent='ğŸ‰ í´ë¦¬ì–´!';

  generateMaze();
  scatterPellets();
  placeActors();
  updateHud();
}
resetBtn.addEventListener('click', resetGame);
overlayReset.addEventListener('click', resetGame);
const homeBtn = document.getElementById('homeBtn');
homeBtn.addEventListener('click', () => {
  location.href = "index.html";
});

resetGame();
requestAnimationFrame(gameStep);
</script>
</body>
</html>
